==========================================
Advanced ORM Techniques: A Practical Guide
==========================================

.. currentmodule:: django.db.models

This guide shows you how to build complex database queries using Django's
ORM, reducing the need for raw SQL. We'll progress from simple to advanced
techniques, showing you that the ORM can handle almost anything you need.

Many developers reach for raw SQL because they don't realize Django provides
tools for building complex queries. This guide demonstrates custom database
functions with :class:`Func`, custom lookups with :class:`Lookup`, and custom
transforms with :class:`Transform`.

.. contents::
    :local:
    :depth: 2

Sample Models
=============

Throughout this guide, we'll use these blog models::

    from django.db import models


    class Author(models.Model):
        name = models.CharField(max_length=100)
        email = models.EmailField()
        bio = models.TextField()
        joined_date = models.DateTimeField(auto_now_add=True)

        def __str__(self):
            return self.name


    class Category(models.Model):
        name = models.CharField(max_length=50)
        slug = models.SlugField()

        def __str__(self):
            return self.name


    class Article(models.Model):
        title = models.CharField(max_length=200)
        slug = models.SlugField(unique=True)
        content = models.TextField()
        author = models.ForeignKey(Author, on_delete=models.CASCADE)
        category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)
        published_date = models.DateTimeField(null=True, blank=True)
        view_count = models.IntegerField(default=0)

        def __str__(self):
            return self.title


    class Comment(models.Model):
        article = models.ForeignKey(
            Article, on_delete=models.CASCADE, related_name="comments"
        )
        author_name = models.CharField(max_length=100)
        content = models.TextField()
        created_date = models.DateTimeField(auto_now_add=True)
        is_approved = models.BooleanField(default=False)

        def __str__(self):
            return f"Comment by {self.author_name}"

Example 1: Simple Custom Database Function
===========================================

Let's start with a simple custom function. Suppose we want to calculate the
reading time for articles (words divided by 200 words per minute)::

    from django.db.models import Func, IntegerField


    class ReadingTime(Func):
        """Calculate approximate reading time in minutes."""

        function = "LENGTH"
        output_field = IntegerField()

        def as_sql(self, compiler, connection):
            # Get the SQL for the field we're operating on
            sql, params = compiler.compile(self.source_expressions[0])
            # Divide word count by 200 (average reading speed)
            return f"(LENGTH({sql}) - LENGTH(REPLACE({sql}, ' ', '')) + 1) / 200", params

Usage::

    from django.db.models import F

    # Annotate articles with reading time
    articles = Article.objects.annotate(reading_time=ReadingTime(F("content"))).filter(
        reading_time__lte=5
    )

    # Find articles that take 5 minutes or less to read
    for article in articles:
        print(f"{article.title}: {article.reading_time} minutes")

**When to use this:** When you need a database-level calculation that's
not provided by Django's :doc:`built-in database
functions</ref/models/database-functions>`.

Example 2: Basic Custom Lookup
===============================

Let's create a lookup to find articles published within the last N days::

    from django.db.models import Lookup
    from django.utils import timezone
    from datetime import timedelta


    class WithinDaysLookup(Lookup):
        lookup_name = "within_days"

        def as_sql(self, compiler, connection):
            lhs, lhs_params = self.process_lhs(compiler, connection)
            rhs, rhs_params = self.process_rhs(compiler, connection)

            # Calculate the date N days ago
            params = lhs_params + rhs_params
            return f"{lhs} >= CURRENT_DATE - INTERVAL '{rhs}' DAY", params

Register it::

    from django.db.models import DateTimeField

    DateTimeField.register_lookup(WithinDaysLookup)

Usage::

    # Find articles published within last 7 days
    recent = Article.objects.filter(published_date__within_days=7)

    # Find articles published within last 30 days
    monthly = Article.objects.filter(published_date__within_days=30)

**When to use this:** When you repeatedly use the same filter pattern and want
a cleaner, more readable syntax.

Example 3: Simple Transform
============================

Transforms modify field values before lookups. Let's create a transform to get
the first N characters of a text field::

    from django.db.models import Transform, CharField


    class FirstChars(Transform):
        lookup_name = "first_chars"

        def __init__(self, expression, length, **extra):
            super().__init__(expression, **extra)
            self.length = length

        def as_sql(self, compiler, connection):
            lhs, params = compiler.compile(self.lhs)
            return f"SUBSTR({lhs}, 1, {self.length})", params

        @property
        def output_field(self):
            return CharField()

Register it::

    from django.db.models import TextField

    TextField.register_lookup(FirstChars)

Usage::

    # Find articles whose titles start with "How"
    Article.objects.filter(title__first_chars__startswith="How")

    # More readable than:
    Article.objects.filter(title__startswith="How")

Example 4: Custom Aggregate Function
=====================================

Create a custom aggregate to calculate the median::

    from django.db.models import Aggregate


    class Median(Aggregate):
        function = "PERCENTILE_CONT"
        template = "%(function)s(0.5) WITHIN GROUP (ORDER BY %(expressions)s)"
        output_field = models.FloatField()

Usage::

    from django.db.models import Avg

    # Compare average vs median view count
    stats = Article.objects.aggregate(
        avg_views=Avg("view_count"), median_views=Median("view_count")
    )
    print(f"Average: {stats['avg_views']}, Median: {stats['median_views']}")

**When to use this:** When Django's built-in aggregates (Avg, Sum, Count, etc.)
don't provide what you need.

Example 5: Chaining Transforms
===============================

Transforms can be chained together. Let's create a transform to get the last
word of a text field::

    class LastWord(Transform):
        lookup_name = "last_word"

        def as_sql(self, compiler, connection):
            lhs, params = compiler.compile(self.lhs)
            # Get everything after the last space
            return (f"SUBSTR({lhs}, INSTR({lhs}, ' ') + 1, LENGTH({lhs}))", params)

        @property
        def output_field(self):
            return CharField()


    TextField.register_lookup(LastWord)

Now chain it::

    # Find authors whose last name starts with 'S'
    Author.objects.filter(name__last_word__startswith="S")

    # Chain with lower() transform
    Author.objects.filter(name__lower__last_word__exact="smith")

Example 6: Complex Lookup with Multiple Conditions
===================================================

Create a lookup that checks if a date is within a date range::

    class BetweenDates(Lookup):
        lookup_name = "between_dates"

        def as_sql(self, compiler, connection):
            lhs, lhs_params = self.process_lhs(compiler, connection)
            rhs, rhs_params = self.process_rhs(compiler, connection)

            # Expecting rhs to be a tuple of (start_date, end_date)
            return f"{lhs} BETWEEN %s AND %s", lhs_params + rhs_params


    DateTimeField.register_lookup(BetweenDates)

Usage::

    from datetime import date

    # Find articles published in a specific date range
    start = date(2024, 1, 1)
    end = date(2024, 12, 31)

    Article.objects.filter(published_date__between_dates=(start, end))

Example 7: Database-Specific Functions
=======================================

Create a function that works differently on different databases::

    class FullTextSearch(Func):
        function = None  # Set dynamically

        def as_sql(self, compiler, connection):
            if connection.vendor == "postgresql":
                # PostgreSQL full-text search
                return (
                    "to_tsvector(%s) @@ plainto_tsquery(%s)",
                    self.get_source_expressions(),
                )
            elif connection.vendor == "mysql":
                # MySQL MATCH AGAINST
                return (
                    "MATCH(%s) AGAINST(%s IN NATURAL LANGUAGE MODE)",
                    self.get_source_expressions(),
                )
            else:
                # Fallback to LIKE
                sql, params = compiler.compile(self.source_expressions[0])
                return f"{sql} LIKE %s", params

Usage::

    # Full-text search across articles
    Article.objects.annotate(
        relevance=FullTextSearch(F("content"), Value("django orm"))
    ).filter(relevance__gt=0)

Example 8: Custom Function with Multiple Arguments
===================================================

Create a function to calculate distance between two points::

    from django.db.models import Func, FloatField, Value
    from math import radians


    class HaversineDistance(Func):
        """Calculate distance in kilometers between two lat/lon points."""

        function = ""
        output_field = FloatField()

        def __init__(self, lat1, lon1, lat2, lon2, **extra):
            expressions = [lat1, lon1, lat2, lon2]
            super().__init__(*expressions, **extra)

        def as_sql(self, compiler, connection):
            lat1, lon1, lat2, lon2 = [
                compiler.compile(expr)[0] for expr in self.source_expressions
            ]

            # Haversine formula
            sql = f"""
                6371 * 2 * ASIN(SQRT(
                    POWER(SIN((RADIANS({lat2}) - RADIANS({lat1})) / 2), 2) +
                    COS(RADIANS({lat1})) * COS(RADIANS({lat2})) *
                    POWER(SIN((RADIANS({lon2}) - RADIANS({lon1})) / 2), 2)
                ))
            """

            params = []
            for expr in self.source_expressions:
                _, expr_params = compiler.compile(expr)
                params.extend(expr_params)

            return sql, params

Usage (if your models had coordinates)::

    # Find articles written by authors within 50km
    nearby = Article.objects.annotate(
        distance=HaversineDistance(
            F("author__latitude"),
            F("author__longitude"),
            Value(44.9778),  # Your latitude
            Value(-93.2650),  # Your longitude
        )
    ).filter(distance__lte=50)

Example 9: Subquery with Custom Logic
======================================

Use subqueries to solve complex problems::

    from django.db.models import Subquery, OuterRef, Count, Q

    # Find authors with more approved comments than rejected
    approved_count = (
        Comment.objects.filter(article__author=OuterRef("pk"), is_approved=True)
        .values("article__author")
        .annotate(count=Count("id"))
        .values("count")
    )

    rejected_count = (
        Comment.objects.filter(article__author=OuterRef("pk"), is_approved=False)
        .values("article__author")
        .annotate(count=Count("id"))
        .values("count")
    )

    authors = Author.objects.annotate(
        approved=Subquery(approved_count), rejected=Subquery(rejected_count)
    ).filter(approved__gt=F("rejected"))

Example 10: Complex Annotation with Func
=========================================

Combine multiple techniques for complex calculations::

    from django.db.models import F, Q, Case, When, Value, FloatField, Count
    from django.db.models.functions import Cast, Coalesce
    from django.utils import timezone
    from datetime import timedelta

    # Calculate engagement score: (comments * 2 + views) / days_since_publish
    articles = Article.objects.annotate(
        comment_count=Count("comments"),
        days_old=Cast(
            (timezone.now() - F("published_date")) / timedelta(days=1), FloatField()
        ),
        engagement_score=Case(
            When(
                days_old__gt=0,
                then=((F("comment_count") * 2 + F("view_count")) / F("days_old")),
            ),
            default=Value(0),
            output_field=FloatField(),
        ),
    ).order_by("-engagement_score")

Example 11: Conditional Aggregation
====================================

Use Case/When for conditional counting::

    from django.db.models import Count, Q, Case, When, IntegerField, F, Value, FloatField
    from django.db.models.functions import Cast

    # Count comments by approval status
    article_stats = Article.objects.annotate(
        total_comments=Count("comments"),
        approved_comments=Count("comments", filter=Q(comments__is_approved=True)),
        pending_comments=Count("comments", filter=Q(comments__is_approved=False)),
        approval_rate=Case(
            When(
                total_comments__gt=0,
                then=Cast(F("approved_comments"), FloatField()) / F("total_comments") * 100,
            ),
            default=Value(0),
            output_field=FloatField(),
        ),
    )

Example 12: Full Complex Query
===============================

Putting it all together - a real-world reporting query::

    from django.db.models import (
        Count,
        Sum,
        Avg,
        F,
        Q,
        Value,
        CharField,
        Case,
        When,
        OuterRef,
        Subquery,
        Exists,
    )
    from django.db.models.functions import Coalesce, TruncMonth

    # Monthly article report with engagement metrics

    # Subquery: Has any viral comments (>100 characters)
    has_viral_comments = Comment.objects.filter(
        article=OuterRef("pk"), content__length__gte=100, is_approved=True
    )

    monthly_report = (
        Article.objects.annotate(
            month=TruncMonth("published_date"),
            comment_count=Count("comments"),
            approved_count=Count("comments", filter=Q(comments__is_approved=True)),
            avg_comment_length=Avg("comments__content__length"),
            has_viral_content=Exists(has_viral_comments),
            engagement_score=(F("view_count") + F("comment_count") * 10) / 100,
            status=Case(
                When(engagement_score__gte=10, then=Value("Hot")),
                When(engagement_score__gte=5, then=Value("Warm")),
                default=Value("Cold"),
                output_field=CharField(),
            ),
        )
        .values("month", "author__name", "category__name")
        .annotate(
            article_count=Count("id"),
            total_views=Sum("view_count"),
            avg_engagement=Avg("engagement_score"),
        )
        .order_by("-month", "-total_views")
    )

This single ORM query replaces what would be complex raw SQL with JOIN
operations, subqueries, and conditional logic!

When to Use Custom Functions, Lookups, and Transforms
======================================================

Custom Func
-----------

Use when you need:

* Database-specific functions not in Django
* Complex calculations at database level
* Performance optimization (database does the work)

**Examples:**
* String manipulation (REGEXP, SOUNDEX)
* Mathematical operations (POW, SQRT, custom formulas)
* Date calculations (business days, fiscal quarters)

Custom Lookup
--------------

Use when you need:

* Reusable filter patterns
* Cleaner query syntax
* Complex WHERE conditions
* New comparison operators

**Examples:**
* Date range checks (within_days, in_quarter)
* String similarity (sounds_like, fuzzy_match)
* JSON operations (jsonb_contains)

Custom Transform
----------------

Use when you need:

* Field value modifications before filtering
* Chainable operations
* Reusable field transformations

**Examples:**
* Text extraction (first_word, last_n_chars)
* Date parts (fiscal_year, week_number)
* JSON path access (json_key, array_element)

Common Patterns
===============

Pattern 1: Avoiding N+1 Queries
--------------------------------

Instead of::

    # BAD: N+1 queries
    for article in Article.objects.all():
        comment_count = article.comments.count()  # Additional query!

Do this::

    # GOOD: Single query with annotation
    articles = Article.objects.annotate(comment_count=Count("comments"))
    for article in articles:
        print(article.comment_count)  # No additional query

Pattern 2: Complex Filtering
-----------------------------

Instead of raw SQL::

    # Tempting to use raw SQL:
    # SELECT * FROM article WHERE ...complex condition...

Do this::

    from django.db.models import Q, F

    # Complex Q objects and F expressions
    Article.objects.filter(
        Q(view_count__gt=F("comment_count") * 10)
        | (Q(category__name="Tutorial") & Q(view_count__gte=1000))
    ).exclude(published_date__isnull=True)

Pattern 3: Window Functions
----------------------------

For ranking and running totals::

    from django.db.models import Window, F
    from django.db.models.functions import RowNumber, Rank, DenseRank

    # Rank articles by view count within each category
    articles = Article.objects.annotate(
        rank=Window(
            expression=Rank(), partition_by=[F("category")], order_by=F("view_count").desc()
        )
    ).filter(
        rank__lte=3
    )  # Top 3 in each category

Next Steps
==========

For more information:

* :doc:`/ref/models/lookups` - API reference for lookups and transforms
* :doc:`/ref/models/database-functions` - Built-in database functions
* :doc:`/topics/db/aggregation` - Aggregation guide
* :doc:`/ref/models/expressions` - Query expressions reference
* :doc:`/ref/models/querysets` - QuerySet API reference

For help with complex queries, consider:

* `Django Forum <https://forum.djangoproject.com/>`_ - Ask the community
* `Django Discord <https://discord.gg/django>`_ - Real-time help
* Stack Overflow tag ``django`` - Search existing solutions

If you find yourself writing raw SQL frequently, there's usually an ORM way to
do it - don't hesitate to ask the community!

