PostgreSQL collations and unique constraints
============================================

.. warning::

    When using PostgreSQL, adding non-deterministic collations to existing unique
    :class:`CharField`\s will cause database errors. This is a known limitation
    in Django (Ticket #34898).

The problem
----------

When you have a :class:`CharField` with ``unique=True`` and try to add a
non-deterministic collation to it, PostgreSQL will crash with:

.. code-block:: text

    NotSupportedError: nondeterministic collations are not supported for operator class "varchar_pattern_ops"

This happens because PostgreSQL automatically creates ``varchar_pattern_ops``
indexes for unique text fields, which are incompatible with non-deterministic
collations.

When this occurs
---------------

* ✅ **Works**: Adding both unique constraint and collation together
* ✅ **Works**: Adding collation first, then unique constraint
* ❌ **Fails**: Adding collation to an existing unique field
* ❌ **Fails**: Same issue affects ``db_index=True`` fields

What are non-deterministic collations?
-------------------------------------

Non-deterministic collations don't always produce the same result for the same
input. Common examples include:

* **Case-insensitive collations**: ``'A'`` and ``'a'`` treated as equivalent
* **Locale-specific collations**: Sorting rules that vary by language/region
* **ICU-based collations**: ``und-u-ks-level2`` (case-insensitive)

Recommended solutions
--------------------

Use Meta constraints instead (Recommended)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of ``unique=True`` on the field, use :class:`~django.db.models.UniqueConstraint`:

.. code-block:: python

    from django.db import models
    from django.db.models import UniqueConstraint

    class User(models.Model):
        email = models.CharField(max_length=255, db_collation='case_insensitive')
        
        class Meta:
            constraints = [
                UniqueConstraint(fields=['email'], name='unique_user_email')
            ]

Add both together
~~~~~~~~~~~~~~~~~

If you must use ``unique=True``, add both the unique constraint and collation in
the same migration:

.. code-block:: python

    # models.py
    class User(models.Model):
        email = models.CharField(
            max_length=255, 
            unique=True, 
            db_collation='case_insensitive'
        )

Manual index management
~~~~~~~~~~~~~~~~~~~~~~

For advanced cases, manually manage indexes using :class:`~django.db.models.Index`:

.. code-block:: python

    from django.db import models

    class User(models.Model):
        email = models.CharField(max_length=255, db_collation='case_insensitive')
        
        class Meta:
            indexes = [
                models.Index(fields=['email'], name='user_email_idx')
            ]

Migration strategy
-----------------

If you're upgrading from Django 5.0 to 5.1 and have existing case-insensitive
fields:

1. **Create a new migration** that removes the unique constraint
2. **Add the collation** in the same migration
3. **Re-add the unique constraint** using :class:`~django.db.models.UniqueConstraint`

.. code-block:: python

    # migration.py
    from django.db import migrations, models

    class Migration(migrations.Migration):
        dependencies = [
            ('myapp', '0001_initial'),
        ]

        operations = [
            # Remove unique constraint
            migrations.AlterUniqueTogether(
                name='user',
                unique_together=set(),
            ),
            # Add collation
            migrations.AlterField(
                model_name='user',
                name='email',
                field=models.CharField(
                    max_length=255,
                    db_collation='case_insensitive'
                ),
            ),
            # Re-add unique constraint via Meta
            migrations.AddConstraint(
                model_name='user',
                constraint=models.UniqueConstraint(
                    fields=['email'],
                    name='unique_user_email'
                ),
            ),
        ]

Alternative approaches
---------------------

Use deterministic collations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

If possible, use deterministic collations that are compatible with
``varchar_pattern_ops``:

.. code-block:: python

    # Use binary collation (deterministic)
    email = models.CharField(
        max_length=255, 
        unique=True, 
        db_collation='C'
    )

Handle case sensitivity in application logic
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of relying on database-level case-insensitive collations:

.. code-block:: python

    # In your model manager or queryset
    class UserManager(models.Manager):
        def get_by_email(self, email):
            return self.filter(email__iexact=email).first()

    class User(models.Model):
        email = models.CharField(max_length=255, unique=True)
        objects = UserManager()

Best practices
-------------

1. **Prefer** :class:`~django.db.models.UniqueConstraint` **over** ``unique=True``
   for complex cases
2. **Test migrations thoroughly** on PostgreSQL before deploying
3. **Consider performance implications** of case-insensitive queries
4. **Document your collation choices** for team awareness
5. **Use deterministic collations** when possible for better compatibility

Related issues
-------------

* This issue also affects ``db_index=True`` fields
* Similar problems occur with ``text_pattern_ops`` on :class:`TextField`\s
* Consider using :class:`~django.db.models.Index` for explicit index control

Getting help
-----------

If you encounter this issue:

1. Check the `Django ticket #34898`_ for updates
2. Consider using the workarounds above
3. Test your migration strategy on a copy of your production database first

.. _Django ticket #34898: https://code.djangoproject.com/ticket/34898

Technical details
----------------

What is varchar_pattern_ops?
~~~~~~~~~~~~~~~~~~~~~~~~~~~

``varchar_pattern_ops`` is a PostgreSQL operator class that provides pattern
matching operators (like ``LIKE``, ``ILIKE``, ``~``, ``~*``) for varchar/text
columns. It's automatically created for unique text fields to optimize pattern
matching queries.

Why non-deterministic collations fail
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PostgreSQL's ``varchar_pattern_ops`` indexes work by creating a predictable
ordering of characters for pattern matching. Non-deterministic collations break
this assumption because:

* The ordering might change depending on context
* ``'A'`` and ``'a'`` might be treated as equivalent in some cases
* This makes it impossible to create a reliable index for pattern matching

References
----------

* `Django Ticket #34898`_
* `PostgreSQL Collation Documentation`_
* `Django Database Constraints Documentation`_

.. _PostgreSQL Collation Documentation: https://www.postgresql.org/docs/current/collation.html
.. _Django Database Constraints Documentation: https://docs.djangoproject.com/en/stable/ref/models/constraints/ 