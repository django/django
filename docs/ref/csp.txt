.. _content-security-policy:

=============================
Content Security Policy (CSP)
=============================

.. versionadded:: 5.2

.. module:: django.middleware.csp
   :synopsis: Middleware for Content Security Policy headers

Content Security Policy (CSP) is a web security standard that helps prevent
attacks by controlling the sources from which content can be loaded. CSP
enforcement plays an important role in a comprehensive :doc:`security strategy
</topics/security>`.

.. _using-csp:

Using CSP
=========

To enable CSP in your Django project:

1. Add the CSP middleware to your ``MIDDLEWARE`` setting::

      MIDDLEWARE = [
          # ...
          "django.middleware.csp.ContentSecurityPolicyMiddleware",
          # ...
      ]

2. Configure your CSP policies in your ``settings.py`` using either
   ``SECURE_CSP`` or ``SECURE_CSP_REPORT_ONLY``, or both. The :ref:`CSP Settings
   <csp-settings>` provides more detailed explanation on the differences between
   these two settings::

      from django.conf import csp

      SECURE_CSP = {
          "DIRECTIVES": {
              "default-src": [csp.SELF],
              # Add more directives as needed
          }
      }

      # Or for report-only mode:
      SECURE_CSP_REPORT_ONLY = {
          "DIRECTIVES": {
              "default-src": [csp.SELF],
              # Add more directives as needed
              "report-uri": "/path/to/reports-endpoint/",
          }
      }

.. _csp-settings:

CSP Settings
============

Django's CSP middleware is configured using the settings ``SECURE_CSP`` and
``SECURE_CSP_REPORT_ONLY`` in your ``settings.py`` file.

Overview
--------
The `Content-Security-Policy specification`_ defines two distinct headers with
complementary purposes:

- ``Content-Security-Policy``: Enforces the CSP rules, blocking any content that
  violates the specified directives.
- ``Content-Security-Policy-Report-Only``: Monitors and reports violations
  without enforcing the policy, allowing for non-intrusive testing.

Configuration Options
---------------------
:setting:`SECURE_CSP`

- Used to define the **enforced policy**.
- Sets the ``Content-Security-Policy`` HTTP header.
- Actively blocks content that violates the specified CSP directives.

.. _content-security-policy-report-only:

:setting:`SECURE_CSP_REPORT_ONLY`

- Used to define the **report-only policy**.
- Sets the ``Content-Security-Policy-Report-Only`` HTTP header.
- Monitors and reports violations without blocking content, useful for testing or debugging CSP rules.
- A ``report-uri`` directive should be set to capture these reports.

Structure of the Settings
-------------------------
Both ``SECURE_CSP`` and ``SECURE_CSP_REPORT_ONLY`` are dictionaries that must
include a ``"DIRECTIVES"`` key. The value of this key is another dictionary
containing CSP directives and their corresponding policies.

Here's a comprehensive example that demonstrates a decent starting point for
many applications::

    from django.conf import csp

    SECURE_CSP = {
        "DIRECTIVES": {
            # Here we restrict all content to self-hosted by default. If you
            # rely on third-party resources (e.g., CDNs or APIs) they could be
            # added here or, preferably, with their more selective directive.
            "default-src": [csp.SELF],
            # Restricts the origins that can be used in <base> tags.
            "base-uri": [csp.SELF],
            # Controls where fetch, XHR, WebSocket, and similar requests can go.
            # If your application uses external APIs, analytics platforms, or
            # WebSockets, you'll need to include their domains here.
            "connect-src": [csp.SELF],
            # Restricts the origins from which fonts can be loaded. Add trusted
            # CDNs if you use external fonts to avoid loading issues.
            "font-src": [csp.SELF],
            # Limits where forms can be submitted. If your app interacts with
            # third-party form handlers (e.g., payment gateways or external
            # APIs), include their origins here.
            "form-action": [csp.SELF],
            # Prevents embedding your site in iframes by default. Keeping this
            # as NONE is ideal for preventing clickjacking unless you explicitly
            # allow trusted domains to frame your site.
            "frame-ancestors": [csp.NONE],
            # Restricts the origins of iframes or embedded content. Use NONE if
            # your app doesnâ€™t embed external iframes. Otherwise, include only
            # trusted origins (e.g., YouTube for videos).
            "frame-src": [csp.NONE],
            # Controls where images can be loaded from. Include trusted image
            # CDNs or services, if needed.
            "img-src": [csp.SELF],
            # Restricts audio and video sources. Keep as SELF if media is hosted
            # internally, or add trusted domains (e.g., video platforms or
            # external storage) for external media.
            "media-src": [csp.SELF],
            # Blocks the use of <object>, <embed>, and <applet> tags. These are
            # rarely needed in modern applications and are often vectors for
            # attacks. Keep this as NONE unless absolutely necessary.
            "object-src": [csp.NONE],
            # Limits where scripts can be loaded from. Add external domains
            # if you use third-party scripts.
            # Consider using `csp.NONCE` for inline scripts.
            "script-src": [csp.SELF],
            # Limits where stylesheets can be loaded from. Add external domains
            # if using third-party CSS.
            # Consider using `csp.NONCE` for inline styles.
            "style-src": [csp.SELF],
            # Automatically upgrades all HTTP requests to HTTPS. This is a great
            # default for security, but ensure all dependencies are
            # HTTPS-compatible to avoid breakages.
            "upgrade-insecure-requests": True,
        }
    }

Many other directives (e.g., those with ``'-src'`` in them like ``script-src``,
``img-src``, etc.) fall back to ``default-src`` if they are not explicitly
defined. It is recommended to keep ``default-src`` restrictive and override it
for specific needs in other directives.

.. _`Content-Security-Policy specification`: https://www.w3.org/TR/CSP3/

Decorators
==========

.. module:: django.views.decorators.csp

The examples below assume you are using function-based views. If you
are working with class-based views, you can refer to :ref:`Decorating
class-based views<decorating-class-based-views>`.

.. function:: csp_disabled(enforced=True, report_only=True)(view)

    This decorator marks a view as being disabled from the Content Security Policy
    protection ensured by the middleware. Example::

        from django.http import HttpResponse
        from django.views.decorators.csp import csp_disabled


        @csp_disabled
        def my_view(request):
            return HttpResponse("This view will not have either CSP headers")

    This decorator takes optional boolean arguments ``enforced`` and
    ``report_only`` to customize which header is disabled. By default, both
    headers are disabled. Example::

        from django.http import HttpResponse
        from django.views.decorators.csp import csp_disabled


        @csp_disabled(report_only=False)
        def my_view(request):
            return HttpResponse("This view will only have an enforced CSP header")


        @csp_disabled(enforced=False)
        def another_view(request):
            return HttpResponse("This view will only have a report-only CSP header")


.. function:: csp_override(config, enforced=True, report_only=True)(view)

    This decorator allows you to override the Content Security Policy for a
    specific view.  It takes a dictionary as an argument, similar to the
    ``SECURE_CSP`` and ``SECURE_CSP_REPORT_ONLY`` settings. This decorator also
    takes optional boolean arguments ``enforced`` and ``report_only`` to
    customize which header is overridden. By default, both headers are
    overridden. Example::

        from django.conf import csp
        from django.http import HttpResponse
        from django.views.decorators.csp import csp_override


        @csp_override(
            {
                "default-src": [csp.SELF],
                "img-src": [csp.SELF, "data:"],
            }
        )
        def my_view(request):
            return HttpResponse("Both CSP headers will be overridden")


        @csp_override(
            {
                "default-src": [csp.SELF],
                "img-src": [csp.SELF, "data:"],
            },
            report_only=False,
        )
        def enforced_only_view(request):
            return HttpResponse("Only the enforced CSP header will be overridden")


        @csp_override(
            {
                "default-src": [csp.SELF],
                "img-src": [csp.SELF, "data:"],
            },
            enforced=False,
        )
        def report_only_view(request):
            return HttpResponse("Only the report-only CSP header will be overridden")

These decorators provide fine-grained control over the Content Security Policy
on a per-view basis, allowing you to customize the policy as needed for specific
parts of your application.

Nonce Usage
===========

A CSP nonce (short for "number used once") is a unique, random value generated
for each HTTP response and included in the ``Content-Security-Policy`` header.
It allows inline scripts or styles to be safely executed if they include a
matching nonce attribute. This mechanism ensures that only explicitly authorized
inline content is executed, effectively preventing unauthorized or malicious
inline scripts, such as those introduced through Cross-Site Scripting (XSS)
attacks. CSP nonces allow you to safely use inline scripts or styles in your
application without the need to use the less secure ``unsafe-inline`` directive,
offering a balance between functionality and security.

To use nonces in your CSP policy:

1. Include the ``csp.NONCE`` value in your CSP settings. This only applies to
   ``script-src`` or ``style-src``::

      from django.conf import csp

      SECURE_CSP = {
          "DIRECTIVES": {
              "default-src": [csp.SELF],
              # Allows self-hosted scripts and script tags with the matching
              # `nonce=` attribute
              "script-src": [csp.SELF, csp.NONCE],
              # Example of the less secure ``unsafe-inline`` option
              "style-src": [csp.SELF, csp.UNSAFE_INLINE],
          }
      }

2. Add the CSP context processor to your ``TEMPLATES`` setting, which makes the
   ``request.csp_nonce`` available in all templates::

      TEMPLATES = [
          {
              "BACKEND": "django.template.backends.django.DjangoTemplates",
              "OPTIONS": {
                  "context_processors": [
                      # ...
                      "django.template.context_processors.csp_nonce",
                  ],
              },
          },
      ]

3. In your templates, use the ``request.csp_nonce`` to output the nonce value:

   .. code-block:: html

      <script nonce="{{ request.csp_nonce }}">
          // Your inline JavaScript
      </script>

The CSP middleware will automatically generate and include a nonce in the CSP
header for each request.

.. note::

    The CSP nonce is included in the header only if ``request.csp_nonce`` is
    accessed at some point between when the middleware processes the request and
    the response. This ensures the nonce is generated and included only when
    necessary.

    If the Django CSP settings do not explicitly include the ``csp.NONCE``
    directive and ``request.csp_nonce`` is accessed in a template, the nonce
    will appear in the content but not in the CSP header. This discrepancy may
    lead to confusion or unexpected behavior.

    To avoid such issues:

    * Ensure that the CSP policy in your headers explicitly includes the
      ``csp.NONCE`` directive when using nonces in your templates.
    * Verify that both your CSP header and content are aligned for proper
      security enforcement.

Limitations and Considerations
==============================

While Content Security Policy (CSP) is a powerful security feature, it's
important to be aware of its limitations and considerations, especially in the
context of Django's implementation:

* Policy Exclusion Risks: Weakening or excluding a CSP policy on any page can
  compromise the security of the entire site. Due to the "same origin" policy,
  an attacker can exploit a vulnerability on one page to access other parts of
  the site. Therefore, excluding any path from CSP protection negates its
  benefits across the site.

* Third-party Integration Complexity: If your application relies heavily on
  third-party scripts or services, implementing a strict CSP can be challenging
  and may require careful configuration and ongoing maintenance.

* Nonce Caching Challenges: Nonces are single-use tokens. If your project uses
  caching, take into consideration that caching can potentially lead to
  mismatches between the CSP header and the content, requiring careful cache
  configuration to ensure consistency.

* Limited Directive Validation: Django's CSP middleware doesn't validate that
  all specified directives match the CSP specification. It's the developer's
  responsibility to ensure the correctness of the directives.

* Report-Only Mode Limitations: While useful for testing, the report-only mode
  (``SECURE_CSP_REPORT_ONLY``) doesn't actually prevent any violations, it only
  reports them.

* Violation Report Handling: While Django provides a way to set up CSP
  reporting, it doesn't include built-in functionality to handle and analyze
  these reports. You'll need to implement this separately or use a 3rd party
  service if you want to make use of violation reports.

* Performance Overhead: Implementing CSP, especially with nonces, can have a
  performance impact due to the additional header processing and nonce
  generation required for each request.

* Browser Support Variations: While most modern browsers support CSP, support
  for specific directives can vary significantly between browsers and versions.

Remember, while these limitations exist, CSP is still a valuable tool in your
security arsenal. It's important to understand these constraints and plan your
implementation accordingly.
