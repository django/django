"""
Creates or renames permissions for all installed apps that need permissions.
"""

import getpass
import sys
import textwrap
import unicodedata

from django.apps import apps as global_apps
from django.contrib.auth import get_permission_codename
from django.contrib.contenttypes.management import create_contenttypes
from django.core import exceptions
from django.db import DEFAULT_DB_ALIAS, migrations, router, transaction
from django.db.models.deletion import Collector
from django.db.utils import IntegrityError


def _get_all_permissions(opts):
    """
    Return (codename, name) for all permissions in the given opts.
    """
    return [*_get_builtin_permissions(opts), *opts.permissions]


def _get_builtin_permissions(opts):
    """
    Return (codename, name) for all autogenerated permissions.
    By default, this is ('add', 'change', 'delete', 'view')
    """
    return [
        _get_permission_for_action(action, opts) for action in opts.default_permissions
    ]


def _get_permission_for_action(action, opts):
    return (
        get_permission_codename(action, opts),
        "Can %s %s" % (action, opts.verbose_name_raw),
    )


def create_permissions(
    app_config,
    verbosity=2,
    interactive=True,
    using=DEFAULT_DB_ALIAS,
    apps=global_apps,
    **kwargs,
):
    if not app_config.models_module:
        return

    try:
        Permission = apps.get_model("auth", "Permission")
    except LookupError:
        return
    if not router.allow_migrate_model(using, Permission):
        return

    # Ensure that contenttypes are created for this app. Needed if
    # 'django.contrib.auth' is in INSTALLED_APPS before
    # 'django.contrib.contenttypes'.
    create_contenttypes(
        app_config,
        verbosity=verbosity,
        interactive=interactive,
        using=using,
        apps=apps,
        **kwargs,
    )

    app_label = app_config.label
    try:
        app_config = apps.get_app_config(app_label)
        ContentType = apps.get_model("contenttypes", "ContentType")
    except LookupError:
        return

    models = list(app_config.get_models())

    # Grab all the ContentTypes.
    ctypes = ContentType.objects.db_manager(using).get_for_models(
        *models, for_concrete_models=False
    )

    # Find all the Permissions that have a content_type for a model we're
    # looking for. We don't need to check for codenames since we already have
    # a list of the ones we're going to create.
    all_perms = set(
        Permission.objects.using(using)
        .filter(
            content_type__in=set(ctypes.values()),
        )
        .values_list("content_type", "codename")
    )

    perms = []
    for model in models:
        ctype = ctypes[model]
        for codename, name in _get_all_permissions(model._meta):
            if (ctype.pk, codename) not in all_perms:
                permission = Permission()
                permission._state.db = using
                permission.codename = codename
                permission.name = name
                permission.content_type = ctype
                perms.append(permission)

    Permission.objects.using(using).bulk_create(perms)
    if verbosity >= 2:
        for perm in perms:
            print("Adding permission '%s'" % perm)


def rename_permissions_after_model_rename(
    app_config,
    verbosity=2,
    interactive=True,
    using=DEFAULT_DB_ALIAS,
    apps=global_apps,
    plan=None,
    **kwargs,
):
    if not app_config.models_module:
        return

    try:
        Permission = apps.get_model("auth", "Permission")
    except LookupError:
        return
    if not router.allow_migrate_model(using, Permission):
        return

    # Collect (app_label, from_model, to_model) tuples.
    renames = [
        (
            (migration.app_label, op.new_name, op.old_name)
            if backward
            else (migration.app_label, op.old_name, op.new_name)
        )
        for migration, backward in (plan or [])
        for op in migration.operations
        if isinstance(op, migrations.RenameModel)
    ]

    if not renames:
        return

    stdout = kwargs.get("stdout", sys.stdout)
    conflicts = []
    for app_label, from_model_name, to_model_name in renames:
        try:
            new_model = apps.get_model(app_label + "." + to_model_name)
        except LookupError:
            continue
        perms = Permission.objects.using(using).filter(
            content_type__app_label=app_label,
            codename__in=[
                action + "_" + from_model_name.lower()
                for action in new_model._meta.default_permissions
            ],
        )

        for perm in perms:
            for action in new_model._meta.default_permissions:
                if not perm.codename.startswith(action + "_"):
                    continue
                new_codename, new_name_str = _get_permission_for_action(
                    action, new_model._meta
                )
                if perm.codename == new_codename and perm.name == new_name_str:
                    continue

                old_name_str = perm.name
                perm.codename = new_codename
                perm.name = new_name_str

                try:
                    perm.save(update_fields={"codename", "name"}, using=using)
                except IntegrityError:
                    # Conflicts are most likely to arise from pre-Django 6.0
                    # projects before permission renames were handled.
                    conflicts.append((perm, old_name_str, new_codename))
                else:
                    if verbosity >= 2:
                        msg = f"Renamed permission: {app_label}.{old_name_str}"
                        msg += f" → {new_name_str}"
                        stdout.write(msg)

    if conflicts:
        stdout.write("The following permissions already existed:\n")
        real_model = global_apps.get_model("auth", "Permission")
        for perm, old_name_str, new_codename in conflicts:
            stdout.write(f"   - {real_model.__str__(perm)}\n")
        if interactive:
            msg = "Would you like to delete the stale permissions and proceed "
            msg += "with the renaming?\n"
            stdout.write(msg)
            confirm = input("Type 'yes' to continue, or 'no' to cancel: ")
            if confirm == "yes":
                conflict_info = []
                for perm, old_name_str, new_codename in conflicts:
                    collector = Collector(
                        using=using, origin=perm, force_collection=True
                    )
                    collector.collect([perm])
                    for obj_type, objs in collector.data.items():
                        if objs != {perm}:
                            conflict_info.append(
                                "    - %s %s object(s)"
                                % (len(objs), obj_type._meta.label)
                            )
                if conflict_info:
                    conflict_display = "\n".join(conflict_info)
                    stdout.write(
                        textwrap.dedent(
                            f"""
                        Any objects that depend on these permissions will also be
                        deleted. The permissions and dependent objects that would
                        be deleted are:

                        {conflict_display}

                        This list doesn't include any cascade deletions to data outside
                        of Django's models (uncommon).

                        Are you sure you want to delete these permissions?
                        If you're unsure, answer 'no'."""
                        )
                    )
                    confirm = input("Type 'yes' to continue, or 'no' to cancel: ")

            if confirm == "yes":
                for perm, old_name_str, new_codename in conflicts:
                    with transaction.atomic(using=using):
                        Permission.objects.using(using).filter(
                            content_type=perm.content_type_id,
                            codename=new_codename,
                        ).exclude(pk=perm.pk).delete()

                        perm.save(update_fields={"codename", "name"}, using=using)
                    if verbosity >= 2:
                        stdout.write(f"Deleted permission: {perm.name}")
                        msg = f"Renamed permission: {app_label}.{old_name_str}"
                        msg += f" → {perm.name}"
                        stdout.write(msg)
            else:
                if verbosity >= 2:
                    msg = "Stale permissions remain. Renconcile permissions manually.\n"
                    stdout.write(msg)


def get_system_username():
    """
    Return the current system user's username, or an empty string if the
    username could not be determined.
    """
    try:
        result = getpass.getuser()
    except (ImportError, KeyError, OSError):
        # TODO: Drop ImportError and KeyError when dropping support for PY312.
        # KeyError (Python <3.13) or OSError (Python 3.13+) will be raised by
        # os.getpwuid() (called by getuser()) if there is no corresponding
        # entry in the /etc/passwd file (for example, in a very restricted
        # chroot environment).
        return ""
    return result


def get_default_username(check_db=True, database=DEFAULT_DB_ALIAS):
    """
    Try to determine the current system user's username to use as a default.

    :param check_db: If ``True``, requires that the username does not match an
        existing ``auth.User`` (otherwise returns an empty string).
    :param database: The database where the unique check will be performed.
    :returns: The username, or an empty string if no username can be
        determined or the suggested username is already taken.
    """
    # This file is used in apps.py, it should not trigger models import.
    from django.contrib.auth import models as auth_app

    # If the User model has been swapped out, we can't make any assumptions
    # about the default user name.
    if auth_app.User._meta.swapped:
        return ""

    default_username = get_system_username()
    try:
        default_username = (
            unicodedata.normalize("NFKD", default_username)
            .encode("ascii", "ignore")
            .decode("ascii")
            .replace(" ", "")
            .lower()
        )
    except UnicodeDecodeError:
        return ""

    # Run the username validator
    try:
        auth_app.User._meta.get_field("username").run_validators(default_username)
    except exceptions.ValidationError:
        return ""

    # Don't return the default username if it is already taken.
    if check_db and default_username:
        try:
            auth_app.User._default_manager.db_manager(database).get(
                username=default_username,
            )
        except auth_app.User.DoesNotExist:
            pass
        else:
            return ""
    return default_username
