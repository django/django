"""
Creates permissions for all installed apps that need permissions.
"""
import getpass
import re
import unicodedata

from django.apps import apps as global_apps
from django.contrib.auth import get_permission_codename
from django.core import exceptions
from django.db import DEFAULT_DB_ALIAS, migrations, router
from django.utils import six
from django.utils.encoding import DEFAULT_LOCALE_ENCODING
from django.utils.text import camel_case_to_spaces


class RenamePermissions(migrations.RunPython):
    def __init__(self, app_label, old_model, new_model):
        self.app_label = app_label
        self.old_model = old_model
        self.new_model = new_model
        super(RenamePermissions, self).__init__(self.rename_forwards, self.rename_backwards)

    def _rename(self, apps, schema_editor, backward=False):
        Permission = apps.get_model('auth', 'Permission')
        db = schema_editor.connection.alias
        if not router.allow_migrate_model(db, Permission):
            return

        old_model_lower = self.old_model.lower()
        new_model_lower = self.new_model.lower()

        current_model = apps.get_model(app_label=self.app_label, model_name=new_model_lower)

        # Build a dictionary allowing to do the correspondence between the
        # current permission codenames and the new <codename, name> values.
        current_to_new_perms = {}
        for codename, name in _get_builtin_permissions(current_model._meta):
            old_codename = re.sub(r'_%s$' % (new_model_lower), '_' + old_model_lower, codename)
            if not backward:
                current_to_new_perms[old_codename] = {'codename': codename, 'name': name}
            else:
                action = old_codename.split('_' + old_model_lower, 1)[0]
                current_to_new_perms[codename] = {
                    'codename': old_codename,
                    'name': 'Can %s %s' % (action, camel_case_to_spaces(self.old_model)),
                }

        perms = Permission.objects.db_manager(db).filter(codename__in=current_to_new_perms).order_by('codename')
        for perm in perms:
            old_codename = perm.codename
            perm.codename = current_to_new_perms[old_codename]['codename']
            perm.name = current_to_new_perms[old_codename]['name']
            perm.save(update_fields={'codename', 'name'})

    def rename_forwards(self, apps, schema_editor):
        self._rename(apps, schema_editor)

    def rename_backwards(self, apps, schema_editor):
        self._rename(apps, schema_editor, backward=True)


def inject_rename_permissions_operations(plan=None, apps=global_apps, using=DEFAULT_DB_ALIAS, **kwargs):
    """
    Insert a `RenamePermissions` operation after every planned `RenameModel`
    operation.
    """
    if plan is None:
        return

    # Determine whether or not the Permission model is available.
    try:
        Permission = apps.get_model('auth', 'Permission')
    except LookupError:
        available = False
    else:
        if not router.allow_migrate_model(using, Permission):
            return
        available = True

    for migration, backward in plan:
        if ((migration.app_label, migration.name) == ('auth', '0001_initial')):
            # There's no point in going forward if the initial auth
            # migration is unapplied as the Permission model will be
            # unavailable from this point.
            if backward:
                break
            else:
                available = True
                continue
        # The Permission model is not available yet.
        if not available:
            continue
        inserts = []
        for index, operation in enumerate(migration.operations):
            if isinstance(operation, migrations.RenameModel):
                operation = RenamePermissions(
                    migration.app_label, operation.old_name, operation.new_name
                )
                inserts.append((index + 1, operation))
        for inserted, (index, operation) in enumerate(inserts):
            migration.operations.insert(inserted + index, operation)


def _get_all_permissions(opts):
    """
    Returns (codename, name) for all permissions in the given opts.
    """
    builtin = _get_builtin_permissions(opts)
    custom = list(opts.permissions)
    return builtin + custom


def _get_builtin_permissions(opts):
    """
    Returns (codename, name) for all autogenerated permissions.
    By default, this is ('add', 'change', 'delete')
    """
    perms = []
    for action in opts.default_permissions:
        perms.append((
            get_permission_codename(action, opts),
            'Can %s %s' % (action, opts.verbose_name_raw)
        ))
    return perms


def create_permissions(app_config, verbosity=2, interactive=True, using=DEFAULT_DB_ALIAS, apps=global_apps, **kwargs):
    if not app_config.models_module:
        return

    app_label = app_config.label
    try:
        app_config = apps.get_app_config(app_label)
        ContentType = apps.get_model('contenttypes', 'ContentType')
        Permission = apps.get_model('auth', 'Permission')
    except LookupError:
        return

    if not router.allow_migrate_model(using, Permission):
        return

    # This will hold the permissions we're looking for as
    # (content_type, (codename, name))
    searched_perms = list()
    # The codenames and ctypes that should exist.
    ctypes = set()
    for klass in app_config.get_models():
        # Force looking up the content types in the current database
        # before creating foreign keys to them.
        ctype = ContentType.objects.db_manager(using).get_for_model(klass)

        ctypes.add(ctype)
        for perm in _get_all_permissions(klass._meta):
            searched_perms.append((ctype, perm))

    # Find all the Permissions that have a content_type for a model we're
    # looking for.  We don't need to check for codenames since we already have
    # a list of the ones we're going to create.
    all_perms = set(Permission.objects.using(using).filter(
        content_type__in=ctypes,
    ).values_list(
        "content_type", "codename"
    ))

    perms = [
        Permission(codename=codename, name=name, content_type=ct)
        for ct, (codename, name) in searched_perms
        if (ct.pk, codename) not in all_perms
    ]
    Permission.objects.using(using).bulk_create(perms)
    if verbosity >= 2:
        for perm in perms:
            print("Adding permission '%s'" % perm)


def get_system_username():
    """
    Try to determine the current system user's username.

    :returns: The username as a unicode string, or an empty string if the
        username could not be determined.
    """
    try:
        result = getpass.getuser()
    except (ImportError, KeyError):
        # KeyError will be raised by os.getpwuid() (called by getuser())
        # if there is no corresponding entry in the /etc/passwd file
        # (a very restricted chroot environment, for example).
        return ''
    if six.PY2:
        try:
            result = result.decode(DEFAULT_LOCALE_ENCODING)
        except UnicodeDecodeError:
            # UnicodeDecodeError - preventive treatment for non-latin Windows.
            return ''
    return result


def get_default_username(check_db=True):
    """
    Try to determine the current system user's username to use as a default.

    :param check_db: If ``True``, requires that the username does not match an
        existing ``auth.User`` (otherwise returns an empty string).
    :returns: The username, or an empty string if no username can be
        determined.
    """
    # This file is used in apps.py, it should not trigger models import.
    from django.contrib.auth import models as auth_app

    # If the User model has been swapped out, we can't make any assumptions
    # about the default user name.
    if auth_app.User._meta.swapped:
        return ''

    default_username = get_system_username()
    try:
        default_username = (
            unicodedata.normalize('NFKD', default_username)
            .encode('ascii', 'ignore').decode('ascii')
            .replace(' ', '').lower()
        )
    except UnicodeDecodeError:
        return ''

    # Run the username validator
    try:
        auth_app.User._meta.get_field('username').run_validators(default_username)
    except exceptions.ValidationError:
        return ''

    # Don't return the default username if it is already taken.
    if check_db and default_username:
        try:
            auth_app.User._default_manager.get(username=default_username)
        except auth_app.User.DoesNotExist:
            pass
        else:
            return ''
    return default_username
